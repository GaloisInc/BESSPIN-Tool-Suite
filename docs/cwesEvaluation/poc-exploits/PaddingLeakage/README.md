# Padding Leakage

This document describes a security vulnerability that falls under the
SSITH vulnerability class of Information Leakage (also known as
Information Exposure):

> This vulnerability allows inappropriate access to privileged information in the 
> hardware through intentional or unintentional information sharing. 
> This vulnerability includes inappropriate data transfers, caching mechanisms, 
> and error handling but is not limited to these areas. 

To ensure proper memory alignment compilers will often add byte
padding to structs, bit fields, or unions when they consist of types
with length less than a word.  This proof of concept demonstrates how
this padding can lead to information leakage.

This example is based on the 
[SEI CERT C Coding Standard](https://resources.sei.cmu.edu/downloads/secure-coding/assets/sei-cert-c-coding-standard-2016-v01.pdf) 
3.6 DCL39-C: Avoid information leakage when passing a structure across
a trust boundary.

# Vulnerability Explanation 

The focus of this example is a C `struct` consisting of two `int`s and
one `char`, shown below.

``` {.c}
struct unpaddedStruct {
  int a;
  char b;
  int c;
};
```

Although the sum of the sizes of the individual elements is 9, the
size of the struct is 12 because 3 extra bytes are added to pad the
char to a word size of 4 bytes.  The content of these 3 extra bytes
will be the data already at their memory location.  If this memory
location was not properly deallocated, then the old information will
leak if the struct data is copied elsewhere.

# Leakage Code Sample 

Information leakage requires a leaker, which leaks sensitive
information, and an adversary, which obtains this sensitive
information.  In this example, these two concepts are modeled as C
functions, with `secretTask` as the leaker and `sendToPublicTask` as
the adversary.

The following code demonstrates how sensitive information `secret` can
leak from `secretTask` to `sendToPublicTask`.  In the full example
code, an application creates a struct, stores the secret in it. After
that, it writes a public struct to the same memory location, and sends
it to the public application.

``` {.c .numberLines}
#define POC_PADDINGLEAKAGE_SECRET 0xFFFFFFFF //This is a configurable parameter

/* secretTask writes secret to memory, then writes a struct to the same
   memory location. It sends a copy of that struct to publicTask,
   which leads to leakage of the secret. */

int secretTask () {
	printf("***** Within the secret task *****\n");
	/* Allocate memory for secret */ 
	int* secret_mem = malloc ( 3 * sizeof( int ) );
		
	/* Write secret */
	int secretLoad[3] = { 0xffffffff, POC_PADDINGLEAKAGE_SECRET, 0xffffffff };
	printf ("The secret = "); printByte (&secretLoad[1]);

	if( secret_mem != NULL ) {
		secret_mem = secretLoad;
	} else {
		printf( "Memory could not be allocated for secretLoad\n" );
		return 1;
	}	

	/* Check that secret is same size as struct unpaddedStruct */	
	if (sizeof( secretLoad ) != sizeof( struct unpaddedStruct )) {
		printf ("Error in paddingLeakage.c: size of secretLoad does not equal the size of the struct.");
		return 1;
	}

	/* Cast pointer from int pointer to struct pointer */ 
	struct unpaddedStruct* struct_mem = (struct unpaddedStruct *) secret_mem;

	/* Write struct to allocated memory */ 
	if( struct_mem != NULL ) {
		struct_mem->a = 1;
		struct_mem->b = 2;
		struct_mem->c = 3;
	} else {
		printf( "Memory could not be allocated for struct\n" );
        return 1;
	}

	/* Send data to Task2 using queue, which queues by copy */
	printf ("New value to send (not a secret) = %d\n", struct_mem->b);
	int pStatus = sendToPublicTask (struct_mem);
	if( pStatus != 0 ) {
		printf( "Could not send to the queue.\n" );
		return 1;
	}
 
	return 0;
}

/* The public task receives struct and reveals leakage through padding bytes */
int sendToPublicTask ( struct unpaddedStruct *payload ) {
	printf("***** Within the public task *****\n");
	/* Print struct, including padding bytes */ 
	if( payload != NULL ) {
		printf ("The whole word publicly accessed = "); printByte (&payload->b);	
	} else {
		printf( "Could not receive from the queue.\n" );
		return 1;
	}
    return 0;
}
```

When the full code is run, `FFFFFF02` is printed, so it is apparent
that the secret was leaked in the three padding bytes of element b.

# Fixing the Vulnerable Code 

One way to patch this vulnerabilty is to explicitly add padding bytes
to the struct, as shown below:

``` {.c}
struct paddedStruct {
  int a;
  char b;
  char padding_1, padding_2, padding_3;
  int c;
};
```

This patch is architecture dependent because it depends on the memory
alignment of the system being used.  To ensure that this patch works
with our system, we use C's `static_assert` to check that there are no
unexpected padding bytes that could lead to information leakage.  This
is shown in the code snippet below, which would replace the `/* Write
struct to allocated memory */` part in the
vulnerable code above.

``` {.c}
/* Check for intermediate padding */
static_assert( offsetof( struct paddedStruct, c ) == 
                offsetof( struct paddedStruct, padding_3 ) + 1,
                "Struct contains intermediate padding" );

/* Check for trailing padding */
static_assert( sizeof( struct paddedStruct ) == 
                offsetof( struct paddedStruct, c ) + sizeof( int ),
                "Struct contains trailing padding" );

/* Write struct to allocated memory */ 
if( struct_mem != NULL ) {
        struct_mem->a = 1;
        struct_mem->b = 2;
        struct_mem->c = 3;
        struct_mem->padding_1 = 0;
        struct_mem->padding_2 = 0;
        struct_mem->padding_3 = 0;
} else {
        printf( "Memory could not be allocated for struct\n" );
        return 1;
}
```

The printed bytes are now `00000002`.

# CWE Discussion

The [NIST Bugs Framework](https://samate.nist.gov/BF/) (BF) provides a
succinct language for classifying software bugs, such as Information
Leakage.  We can describe this example using the BF's terminology for
the Information Exposure (IEX) class.  Some attributes are not
applicable (N/A) because this is a theoretical rather
than an applied example.

* Causes: Failure to Properly Sanitize Sensitive Data: Uncleared
  Before Release 
* Attributes:
    * Information/Data: N/A
    * Sensitivity: N/A 
    * Data State: Little 
    * Exposure: Random 
    * Frequency: N/A
    * Channel: Legitimate 
    * Use: N/A 

Hardware could be made secure against this vulnerability by using
tagged memory such as that of Dover Microsystem's CoreGuard.  Tagging
sensitive memory, such as the secret in the example, with permissions
can prevent it from being reused for less sensitive data or from being
inadvertently copied to a memory location with lower permissions.

* The padding leakage vulnerability is strongly related to the following CWEs:
	- [CWE-212](https://cwe.mitre.org/data/definitions/212.html): Improper cross-boundary removal of sensitive data.
	- [CWE-214](https://cwe.mitre.org/data/definitions/214.html): Information exposure through process environment.

* Moreover, it is related to the following CWEs:
	- The top-level type [CWE-200](https://cwe.mitre.org/data/definitions/200.html): Information exposure. And, more specifically, it is an instance of one or more of the following subtypes:
	- [CWE-201](https://cwe.mitre.org/data/definitions/201.html): Information exposure through sent data. This is in case the struct is sent to any other principle.
	- [CWE-215](https://cwe.mitre.org/data/definitions/215.html): Information exposure through debug information. This is in case the information leakage only occurs when the code is compiled with debugging enabled but not otherwise.
	- [CWE-226](https://cwe.mitre.org/data/definitions/226.html): Sensitive information uncleared before release.

* Furthermore, depending upon the semantics of the struct in question, it may be an exemplar for:
	- [CWE-321](https://cwe.mitre.org/data/definitions/321.html): Use of hard-coded cryptographic key. This is in case the struct transiently held key information and it was not cleared properly.
	- [CWE-497](https://cwe.mitre.org/data/definitions/497.html): Exposure of system data to an unauthorized control sphere. This is in case the leaked data relates to secret information that helps an adversary form an attack plan.
	- [CWE-524](https://cwe.mitre.org/data/definitions/524.html): Information exposure through caching. This in case the struct was used for caching.
	- [CWE-707](https://cwe.mitre.org/data/definitions/707.html): Improper enforcement of message or data structure. This is because the struct is not well-formed from a secrecy invariant point-of-view.

# LANDO Specifications for Information Leakage 

Specifications for information leakage must enumerate: (1) where
information is stored, (2) what classification that information can
have, and (3) what amount of leakage is permissible.

We assume that in the LANDO language, information tagged as *high* may
not be leaked via any means to any other information storage location
of lower security classification.  If some leakage is permitted, then
the information flow direction, volume, and time frame must be
specified.

The LANDO specification of a CPU that mitigates this vulnerability is
found in the LANDO file `padding_leakage.lando`.  It is written using
the IEX model developed in the `testgen` project.  The specification
is as follows:
```
myCPU_exposed_data: exposed_data
[ high ]
[ used && transferred ]
[ little ]
myCPU_IL_IEX: iex_weakness
[ data = myCPU_exposed_data ]
[ random ]
[ on_demand ]
[ indirect ]
```
