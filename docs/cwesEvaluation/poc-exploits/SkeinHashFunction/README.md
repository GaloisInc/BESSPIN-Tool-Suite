# Skein

This document describes a vulnerability in the reference implementation
of the Skein cryptographic hash function. This vulnerability illustrates several
CWEs from the "Numeric Errors" class.

Skein is a hash function, similar to the more familiar SHA-1 and SHA-2 families of hash functions.

In 2010, Skein was one of the "final five" contenders in the NIST-sponsored competition to design an algorithm that would become the official "SHA-3" hash function. It did not win.

This proof-of-concept example is based on version 1.3 of the Skein reference implemenation, available from the [official Skein website](http://www.skein-hash.info/).

# Vulnerability Explanation

The Skein hash function is configurable. Notably, the algorithm can be initialized to request any number of bits of output as the hash digest of a variable-length block of data. There are also versions of the algorithm with different internal block sizes of 256, 512, and 1024 bits. For this proof-of-concept, we choose to use the version of Skein with a 512-bit internal block size.

The main Skein API Exports three functions:

* Skein_512_Init &mdash; initializes a "hash context" object, given a requested number of bits of output. This final parameter is called `hashBitLen`.

* Skein_512_Update &mdash; takes a variable-length block of data, hashes it, and keeps record of current hash digest in the given hash context.  This function may be called several times to form a single hash from several blocks of data.

* Skein_512_Final &mdash; takes a hash context object, and returns the final hash digest of all the data. The number of bits of digest returned is given by the value of `hashBitLen` given above.

For example, to hash a given message and produce a 512 bit hash digest, a correct use of the API is as follows:

```
#include "skein.h"
static u08b_t message[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
int r;
Skein_512_Ctxt_t ctx;
u08b_t digest[32];

r = Skein_512_Init (&ctx, 256); // 256 bits is 32 bytes
r = Skein_512_Update (&ctx, &message[0], 16);
r = Skein_512_Final (&ctx, &digest[0]);

// Hash of message is now in digest[0] through digest[31]
```


# Vulnerable Code

Formal verification of the Skein code, originally reported
[here](https://link.springer.com/chapter/10.1007/978-3-642-25032-3_2),
revealed a flaw in the implemenation of `Skein_512_Final` that can be exploited.

Skein_512_Final uses a Cipher-Block-Chaining (CBC) approach to loop over the accumulated
hash context to produce the required number of bits of output, using a block cipher.
To do this, the algorithm must first transform `hashBitLen` into a number of bytes,
rounding up when `hashBitLen` is not a multiple of 8.
It then uses that number of bytes to calculate how many blocks of output are required.
This controls the number of times the finalization loop is executed.

The mathematical specification of Skein describes this correctly, stating

```
"The result consists of the leading ceiling(hashBitLen / 8) bytes of..." (adapted from section 3.5.3 of the specification)
```

where "/" returns a real number and the "ceiling" function takes a real number argument
and returns a positive integer, rounding away from zero.

The C Reference Implemenation from Skein's designers refines this to:

```
byteCnt = (ctx->h.hashBitLen + 7) >> 3;
```

adding 7 to hashBitLen to round up the number of bits before dividing by 8 using a right-shift of 3 bits.
Crucially, we note that the type of hashBitLen is `size_t` which is an `unsigned` type in C.

This calculation is followed by a `for` loop that executs the CBC-mode generation of the required number of blocks of output, thus:

```
for (i=0;i*SKEIN_512_BLOCK_BYTES < byteCnt;i++)
{
   // calculcates and sets output hash digest into *hashVal
}
return SKEIN_SUCCESS;
```

where `hashVal` is a pointer to a suitably-sized array of bytes supplied by the caller that will
receive the final value of the hash.

There is an unstated requirement in this code that the body of this loop must execute at least once,
which in turn means that byteCnt must be greater than or equal to one. If the loop body is never executed, then the data pointed to by hashVal is never updated, and the algorithm returns with hashVal pointed to a potentially uninitialized block of memory. Subsequent reference to that data is an undefined behavior.

The problem then, is that byteCnt _can_ be zero, since the `+ 7` operation's 'ssignment is a _modular_ addition (owing to the type size_t being unsigned), and therefore wraps around. This use of modular addition is essentially an unsound refinement of the mathematical specification, which is expressed in terms of pure mathematical integers.

This vulnerability can be triggered by initializing Skein with a very large value of hashBitLen (within 7 of the modulus implied by the range of size_t, so usually `2^32` or `2^64` depending on the implementation.) The `+ 7` operation then overflows, resulting in a value between 0 and 7. Dividing that by 8 (and rounding towards zero) yields `byteCnt == 0`.

# Exploit explanation

The exploit can be triggered by initializing Skein with a deliberately large value of hashBitLen.  A related possible exploit could occur in code that _calculates_ hashBitLen (also using modular arithmetic) but has a bug that results in an _underflow_ of the calcuation - for example a bug that yields a hashBitLen of -2, but that gets wrapped round to `2**32-2`.

Cryptographically, this is rather worrying.  In simple cases, this means the the algorithm returns a pointer to a possibly uninitialized block of memory. There is no way to test is such a block of memory is or is not the *right answer*, since an arbitrary sequence of bytes may well be a correct hash or not.

More worryingly, repeated application of Skein to _different_ blocks of data might yields the _same_ hash value - something that should _never_ happen with a cryptographically secure hash function.

# Fixing the Vulnerable Code

The code can be fixed in a number of ways:

* Addition of a suitable precondition on Skein_512_Init and its relatives to forbid initialization with the offending large values of hashBitLen.

* Addition of defensive coding to reject any such attempt to initialize the algorithm.

* Modification of Skein_512_Final to correctly compute the number of bytes of output for large values of hashBitLen.

# Test cases and results

This section shows test results generated on RISC-V/Debian using the Chisel_P2 processor, running under QEMU.  Results on other platforms may have slightly different values in the sections where undefined output is expected, but the overall pattern should be the same.

Test Part 1 calls Skein correctly, asking for a 32-byte hash of a small message:

```
--- TEST PoC Skein - Part 1 - 256 bit hash of message1 into digest1 ---
 4D 52 95 53 98 63 91 53 63 8F 32 E6 50 B1 D2 15
 77 D7 2E A7 A6 2B C0 E2 82 78 14 50 AE F8 56 38
```

Test Part 2 calls Skein correctly again, asking for a 32-byte hash of a different message. This shows that a different message produces a different hash:

```
--- TEST PoC Skein - Part 2 - 256 bit hash of message2 into digest1 ---
--- TEST PoC Skein - Part 2 - Should be different from above        ---
 CD CB 7D A0 9D F2 CB 54 81 F8 7F 6A 14 5F 77 96
 66 05 78 80 54 37 D5 6D C2 D9 6B FA 1F 0F E5 25
```

Test Part 3 invokes the vulnerability, asking for the hash of a third (different) message, but storing the resulting hash in the same data buffer as Part 2. This result _should_ be different from that seen in part 2, but it is not:

```
--- TEST PoC Skein - Part 3 - large hash of message3 into digest1 ---
--- TEST PoC Skein - Part 3 - Should be different from hash(message2)   ---
 CD CB 7D A0 9D F2 CB 54 81 F8 7F 6A 14 5F 77 96
 66 05 78 80 54 37 D5 6D C2 D9 6B FA 1F 0F E5 25
```

Test Part 4 hash the same message as in Part 3, invoking the vulnerability once again, but this time putting the resulting hash into a data buffer that has been declared but never initialized:

```
--- TEST PoC Skein - Part 4 - large hash of message3 into digest2 ---
--- TEST PoC Skein - Part 4 - Should be different from hash(message1)   ---
 FF FF FF FF 00 00 00 00 98 9B 8B FF 3F 00 00 00
 88 9B 8B FF 3F 00 00 00 FF FF FF 0F 00 00 00 00
```

This result looks suspicious (the long runs of FF and 00 might indicate memory that has not been initialized), but there is no way of knowing if this really is the correct hash of the message or not.

Test Part 5 hashes a fourth (different again) message into the same data buffer as in Part 3. The result should be different from that seen in Part 3, but it isn't:

```
--- TEST PoC Skein - Part 5 - large bit hash of message4 into digest1 ---
--- TEST PoC Skein - Part 5 - Should be different from hash(message3)   ---
 CD CB 7D A0 9D F2 CB 54 81 F8 7F 6A 14 5F 77 96
 66 05 78 80 54 37 D5 6D C2 D9 6B FA 1F 0F E5 25
```

# CWE Discussion

This vulnerability covers several CWEs from the Numerics grouping.

In particular, the following CWEs are relevant to this example:

* [CWE-128](https://cwe.mitre.org/data/definitions/128.html) and [CWE-190](https://cwe.mitre.org/data/definitions/190.html) cover the initial defect "wrap around" in the calculation of `byteCnt`.

* [CWE-456](https://cwe.mitre.org/data/definitions/456.html) covers the failure to intialize the output of Skein_512_Final.

* [CWE-457](https://cwe.mitre.org/data/definitions/457.html) covers the potential for undefined behavior if that uninitialized hash value is subsequently referenced.

* There is also a case to be made that this vulnerability is a defect in the design of the Skein API, in that it allows the algorithm to be initialized with an erroneous value of hashBitLen in the first place. This case is covered by [CWE-475](https://cwe.mitre.org/data/definitions/475.html), [CWE-628](https://cwe.mitre.org/data/definitions/628.html), and [CWE-687](https://cwe.mitre.org/data/definitions/687.html).

# Sample LANDO Specification

See the specification `skein.lando` in this directory.

# Running the Code

The code for the Skein algorithm itself, plus the "main()" driver function have been concatenated for this example into a single file called `skein.c`. The main() function appears at the very end of the file. The other code is unmodified from the Skein Reference Implementation.
