# Heartbleed

This document describes the security vulnerability known as
"[Heartbleed](http://heartbleed.com/)" or
[CVE-2014-0160](https://nvd.nist.gov/vuln/detail/CVE-2014-0160).
Heartbleed falls under the SSITH CWE class of Buffer Errors:

> This vulnerability allows inappropriate read and/or write access to locations
> within memory associated with variables, data structures or internal program
> data. Inappropriate access to memory is exploited to subvert the normal
> hardware operations creating security vulnerability in the hardware.

[OpenSSL](https://www.openssl.org/) is a popular open-source software library
which implements many cryptographic functions, including the full Transport
Layer Security (TLS) and Secure Sockets Layer (SSL) stack.
The open-source web servers [Apache](https://httpd.apache.org/) and
[nginx](https://nginx.org/en/) both use OpenSSL to encrypt web traffic.

In April 2014, the Heartbleed vulnerability was discovered in OpenSSL's
implementation of the TLS and Datagram Transport Layer Security (DTLS)
heartbeat extension.
Heartbleed allows clients of affected web servers to exfiltrate up to 64 kB of
the server's private memory in a single TLS transaction.
Since the vulnerable memory space is that of the web server process, this
vulnerability exposes many pieces of sensitive information, such as:

* The web server's X.509 private key
* Cryptographic keys for any ongoing TLS sessions
* Decrypted data sent over HTTPS by other web clients, such as plaintext
  passwords.

OpenSSL versions 1.0.1 through 1.0.1f are all vulnerable to Heartbleed.

# TLS/DTLS Heartbeat Extension

The TLS/DTLS heartbeat extension is defined in
[RFC 6520](https://tools.ietf.org/html/rfc6520).
When two networked computers (referred to as "peers") establish a secure
traffic session using TLS or DTLS, they engage in a high-overhead negotiation
procedure.
In the case of TLS, that procedure must be repeated if there is a sufficiently
long pause in traffic between the peers.
In the case of DTLS, the only way a computer can determine if its peer is still
alive is to repeat that negotiation procedure.
The heartbeat extension allows peers to inexpensively keep a connection alive
(for TLS) or check if a peer is responsive (for DTLS).

The heartbeat protocol is a request-response system.
The requesting peer sends a `HeartbeatRequest` message, and the responding peer
is expected to respond with a `HeartbeatResponse` message.
The request message contains a data payload---defined by the requesting
peer---of up to 64 kB.
The response message must contain an exact copy of that payload.
Both messages are structured as follows (see [RFC 6520 Section
4](https://tools.ietf.org/html/rfc6520#section-4)):

```
struct {
  HeartbeatMessageType type;
  uint16 payload_length;
  opaque payload[HeartbeatMessage.payload_length];
  opaque padding[padding_length];
} HeartbeatMessage;
```

* The `type` field (1 byte) is either set to `heartbeat_request` (`1`) or
  `heartbeat_response` (`2`).
* The `payload_length` field (2 bytes) indicates the length of the heartbeat
  payload in bytes.
* The `payload` field (`payload_length` bytes) is the heartbeat payload, which
  the responding peer must echo to the requesting peer.
* The `padding` field is unimportant for this discussion, but must be at least
  16 bytes long.

# Vulnerability Explanation

In both the TLS and DTLS heartbeat response implementations, the vulnerable
versions of the OpenSSL library do not check the actual received length of the
heartbeat request payload.
Instead, `HeartbeatRequest.payload_length` is assumed to be the length of the
payload.
The responding peer then copies `HeartbeatRequest.payload_length` bytes of data
from its heap space into `HeartbeatResponse.payload` and sends that response to
the requesting peer.
An adversarial requesting peer could send a payload with `real_payload_length`
bytes, where `real_payload_length` is less than
`HeartbeatRequest.payload_length`
The responding peer will then respond with `HeartbeatRequest.payload_length`
$-$ `real_payload_length` bytes of private heap memory.
Since `payload_length` is an unsigned 16-bit integer, and `real_payload_length`
could be zero, an adversarial requesting peer could receive 2<sup>16<sup>-1 (or
65535) bytes in each heartbeat response.

# Vulnerable Code

A mirror of the OpenSSL source code is [hosted on
GitHub](https://github.com/openssl/openssl).
In OpenSSL version 1.0.1f, the function
[`tls1_process_heartbeat`](https://github.com/openssl/openssl/blob/OpenSSL_1_0_1f/ssl/t1_lib.c#L2553-L2620)
in the file
[`ssl/t1_lib.c`](https://github.com/openssl/openssl/blob/OpenSSL_1_0_1f/ssl/t1_lib.c)
contains the vulnerable heartbeat response implementation for TLS, and the
function
[`dtls1_process_heartbeat`](https://github.com/openssl/openssl/blob/OpenSSL_1_0_1f/ssl/d1_both.c#L1454-L1522)
in the file
[`ssl/d1_both.c`](https://github.com/openssl/openssl/blob/OpenSSL_1_0_1f/ssl/d1_both.c)
contains the vulnerable heartbeat response implementation for DTLS.

# Heartbleed Code Sample

The following code is a reproduction of the `tls1_process_heartbeat` C function
from the OpenSSL 1.0.1f library, located in the file `ssl/t1_lib.c`.
This function responds to TLS heartbeat requests.
The following changes were made to increase readability:

* Added explanatory comments, using the `//` comment style.
  All comments from the original source code use the `/* */` comment style.
* Removed some code irrelevant to the vulnerability, indicated by `// ...`
  comments.

``` {.c .numberLines}
int
tls1_process_heartbeat(SSL *s)
  {
  // Pointer 'p' points to a HeartbeatMessage struct as defined in RFC6520.
  unsigned char *p = &s->s3->rrec.data[0], *pl;
  unsigned short hbtype;
  unsigned int payload;
  unsigned int padding = 16; /* Use minimum padding */

  /* Read type and payload length first */
  hbtype = *p++;
  // Convert next two bytes pointed to by 'p' into integer 'payload', then
  // increment 'p' by two.
  n2s(p, payload);
  pl = p;

  // ...

  if (hbtype == TLS1_HB_REQUEST)
    {
    unsigned char *buffer, *bp;
    int r;

    /* Allocate memory for the response, size is 1 bytes
     * message type, plus 2 bytes payload length, plus
     * payload, plus padding
     */
    buffer = OPENSSL_malloc(1 + 2 + payload + padding);
    bp = buffer;

    /* Enter response type, length and copy payload */
    *bp++ = TLS1_HB_RESPONSE;
    // Convert the two bytes of 'payload' into two entries in the array pointed
    // to by 'bp', then increment 'bp' by two.
    s2n(payload, bp);
    memcpy(bp, pl, payload);
    bp += payload;
    /* Random padding */
    RAND_pseudo_bytes(bp, padding);

    r = ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);

    // ...

    OPENSSL_free(buffer);

    if (r < 0)
      return r;
    }

  // ...

  return 0;
  }
```

The core of the vulnerability lies in the following code:

* Lines 11 through 15: Set the integer variable `payload` to
  `HeartbeatRequest.payload_length`, and set the pointer variable `pl` to the
  base address of `HeartbeatRequest.payload`.
* Line 28: Allocate enough memory on the heap to hold a `HeartbeatResponse`
  containing a `payload`-byte payload.
* Line 36: Copy `payload` bytes from `HeartbeatRequest.payload` (pointed to by
  `pl`) to `HeartbeatResponse.payload` (pointed to by `bp`).
* Line 41: Send the `HeartbeatResponse` to the requesting peer.

# Fixing the Vulnerable Code

Commit
[`96db902`](https://github.com/openssl/openssl/commit/96db9023b881d7cd9f379b0c154650d6c108e9a3)
in the OpenSSL git repository patches the Heartbleed vulnerability for both TLS
and DTLS.
This patch was released in OpenSSL version 1.0.1g.

Before examining the fix for this vulnerability, recall this section of the
`tls1_process_heartbeat` function, which starts at line 10 in the previous code
sample:

``` {.c}
  /* Read type and payload length first */
  hbtype = *p++;
  n2s(p, payload);
  pl = p;
```

The patch changes the code segment above to the following:

``` {.c}
  /* Read type and payload length first */
  if (1 + 2 + 16 > s->s3->rrec.length)
    return 0; /* silently discard */
  hbtype = *p++;
  n2s(p, payload);
  if (1 + 2 + payload + 16 > s->s3->rrec.length)
    return 0; /* silently discard per RFC 6520 sec. 4 */
  pl = p;
```

The variable `s->s3->rrec.length` is equal to the number of plaintext bytes in
the received `HeartbeatRequest` message.
The added code checks for two conditions:

1. Is the received `HeartbeatRequest` message missing the minimum amount of
   data?
   There must be more than 19 bytes in the message:
    * 1 for `HeartbeatMessage.type`
    * 2 for `HeartbeatMessage.payload_length`
    * `$\geq$`{=latex} 1 for a non-empty `HeartbeatMessage.payload`
    * `$\geq$`{=latex} 16 for `HeartbeatMessage.padding`
2. Is the `HeartbeatMessage.payload_length` (equal to the `payload` variable
   in the code sample above) too large given the length of the received
   plaintext message?

These two conditions ensure that any adversarial `HeartbeatRequest` will be
silently dropped instead of responded to with the server's private memory.

Note that secure hardware would not be vulnerable to Heartbleed in the first
place.
A compiler for secure hardware might recognize the potential for a Buffer Error
and refuse to produce a binary.
A CPU which assigns ownership to fine-grained memory segments might refuse to
read the memory outside of the heartbeat message's plaintext segment.

# CWE Discussion

The [NIST Bugs Framework](https://samate.nist.gov/BF/) (BF) provides a succinct
language for classifying software bugs, such as Buffer Errors.
We can describe Heartbleed using the BF's terminology for the [Buffer Overflow
(BOF) class](https://samate.nist.gov/BF/Classes/BOF.html):

* Causes: Input Not Properly Checked, which leads to Data Exceeds Array
  (specifically Too Much Data).
* Attributes:
    * Access: Read
    * Boundary: Above
    * Location: Heap
    * Magnitude: Far
    * Data Size: Huge
    * Excursion: Continuous
* Consequences: InformationChangeLoss

* The heartbleed vulnerability is related to [CWE-119](https://cwe.mitre.org/data/definitions/119.html): Improper restriction of operations within the bounds of a memory buffer.

# Sample LANDO Specification

To specify that a SSITH CPU is invulnerable solely to this particular
vulnerability, one uses the BOF LANDO model, the following specification (as appended to the background
`bof.cfr` LANDO file) states that the SSITH CPU `myCPU`
is invulnerable to this particular Heartbleed vulnerability:
```
myCPUs_BOF: BOF
[ InputNotCheckedProperly ]
[ Read ]
[ Above ]
[ Heap ]
[ Far ]
[ Huge ]
[ Continuous ]
[ InformationChangeLoss ]
```
See the specification `heartbleed.lando` in this directory.

# Running the Codes

The code is based on the OpenSSL C function `tls1_process_heartbeat`, but instead of running on a web server, this program only prints out exposed memory from this process.   

There are two configurable parameters:
- `poc_heartbleed_real_payload_len`: The real payload length.
- `poc_heartbleed_nominal_payload_len`: The nominal payload length. This should be set less than the real length in order to demonstrate the vulnerability.
